{"version":3,"file":"createEventEmitterProxy.js","sourceRoot":"","sources":["../src/createEventEmitterProxy.ts"],"names":[],"mappings":";;;AAcA,MAAM,UAAU,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC;AAC9B,MAAM,cAAc,GAAwB,CAAC,aAAa,EAAE,gBAAgB,CAAC,CAAC;AAC9E,MAAM,mBAAmB,GAAG,CAAC,IAAqB,EAAE,EAAE,CACpD,CAAC,cAAc,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;AAEjC;;;;;;;;;;;;;;;GAeG;AACH,SAAgB,uBAAuB,CACrC,aAAmB,EACnB,EACE,WAAW,EAAE,gBAAgB,GAAG,UAAU,MAGxC,EAAE;IAEN,gBAAgB;IAChB,MAAM,WAAW,GACf,gBAAgB,KAAK,cAAc;QACjC,CAAC,CAAC,mBAAmB;QACrB,CAAC,CAAC,gBAAgB,CAAC;IAEvB,IAAI,OAAO,WAAW,KAAK,UAAU,EAAE;QACrC,MAAM,IAAI,KAAK,CAAC,+CAA+C,CAAC,CAAC;KAClE;IAED,IAAI,MAAM,GAAG,aAAa,CAAC;IAE3B;;;;OAIG;IACH,IAAI,SAAS,GAAG,CAAC,SAAe,EAAE,EAAE;QAClC,MAAM,SAAS,GAAG,MAAM,CAAC;QACzB,MAAM,GAAG,SAAS,CAAC;QACnB,oBAAoB;QACpB,SAAS;aACN,UAAU,EAAE;aACZ,MAAM,CAAC,WAAW,CAAC;aACnB,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;YAChB,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;gBAC/C,iEAAiE;gBACjE,oCAAoC;gBACpC,SAAS,CAAC,EAAE,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;YAC9B,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QACL,aAAa;QACb,SAAS,CAAC,kBAAkB,EAAE,CAAC;IACjC,CAAC,CAAC;IAEF,MAAM,KAAK,GAAG,IAAI,KAAK,CAAO,MAAM,EAAE;QACpC,yEAAyE;QACzE,wEAAwE;QACxE,0EAA0E;QAC1E,2EAA2E;QAC3E,8CAA8C;QAC9C,GAAG,CACD,OAAa,EACb,IAA8B,EAC9B,QAA8B;YAE9B,8BAA8B;YAC9B,IAAI,IAAI,KAAK,WAAW,EAAE;gBACxB,OAAO,SAAS,CAAC;aAClB;YAED,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;YAC3B,IAAI,KAAK,YAAY,QAAQ,EAAE;gBAC7B,OAAO,UAAyB,GAAG,IAAW;oBAC5C,6DAA6D;oBAC7D,2CAA2C;oBAC3C,OAAO,KAAK,CAAC,KAAK,CAAC,IAAI,KAAK,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBAC9D,CAAC,CAAC;aACH;YACD,OAAO,KAAK,CAAC;QACf,CAAC;QACD,yEAAyE;QACzE,wEAAwE;QACxE,0EAA0E;QAC1E,2EAA2E;QAC3E,8CAA8C;QAC9C,GAAG,CACD,OAAa,EACb,IAA8B;QAC9B,sEAAsE;QACtE,6EAA6E;QAC7E,uEAAuE;QACvE,qEAAqE;QACrE,6CAA6C;QAC7C,KAAU;YAEV,8BAA8B;YAC9B,IAAI,IAAI,KAAK,WAAW,EAAE;gBACxB,SAAS,GAAG,KAAK,CAAC;gBAClB,OAAO,IAAI,CAAC;aACb;YACD,MAAM,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;YACrB,OAAO,IAAI,CAAC;QACd,CAAC;KACF,CAAC,CAAC;IAEH,0EAA0E;IAC1E,8EAA8E;IAC9E,4EAA4E;IAC5E,sEAAsE;IACtE,oEAAoE;IACpE,OAAO,KAA6B,CAAC;AACvC,CAAC;AApGD,0DAoGC","sourcesContent":["import type { SwappableProxy } from './types';\n\n/**\n * A portion of Node's EventEmitter interface that `createEventEmitterProxy`\n * expects its `target` to support.\n */\ntype EventEmitterLike = {\n  eventNames: () => (string | symbol)[];\n  // The `rawListeners` method returns an array of `Function`s.\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  rawListeners(eventName: string | symbol): Function[];\n  removeAllListeners(event?: string | symbol): EventEmitterLike;\n};\n\nconst filterNoop = () => true;\nconst internalEvents: (string | symbol)[] = ['newListener', 'removeListener'];\nconst externalEventFilter = (name: string | symbol) =>\n  !internalEvents.includes(name);\n\n/**\n * Creates a proxy object that initially points to the given object but whose\n * target can be substituted with another object later using its `setTarget`\n * method. In addition, when the target is changed, event listeners which have\n * been attached to the target will be detached and migrated to the new target.\n *\n * @template Type - An object that implements at least `eventNames`, `rawListeners`,\n * and `removeAllListeners` from [Node's EventEmitter interface](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/node/events.d.ts).\n * @param initialTarget - The initial object you want to wrap.\n * @param opts - The options.\n * @param opts.eventFilter - Usually, listeners for all events will be migrated\n * from old targets to new targets, but this function can be used to select\n * which events you want to migrate. If you pass `'skipInternal'`, then\n * `newListener` and `removeListener` will be excluded.\n * @returns The proxy object.\n */\nexport function createEventEmitterProxy<Type extends EventEmitterLike>(\n  initialTarget: Type,\n  {\n    eventFilter: givenEventFilter = filterNoop,\n  }: {\n    eventFilter?: ((eventName: string | symbol) => boolean) | 'skipInternal';\n  } = {},\n): SwappableProxy<Type> {\n  // parse options\n  const eventFilter =\n    givenEventFilter === 'skipInternal'\n      ? externalEventFilter\n      : givenEventFilter;\n\n  if (typeof eventFilter !== 'function') {\n    throw new Error('createEventEmitterProxy - Invalid eventFilter');\n  }\n\n  let target = initialTarget;\n\n  /**\n   * Changes the object that the proxy wraps.\n   *\n   * @param newTarget - The new object.\n   */\n  let setTarget = (newTarget: Type) => {\n    const oldTarget = target;\n    target = newTarget;\n    // migrate listeners\n    oldTarget\n      .eventNames()\n      .filter(eventFilter)\n      .forEach((name) => {\n        oldTarget.rawListeners(name).forEach((handler) => {\n          // @ts-expect-error `rawListeners` returns `Function[]`, but `on`\n          // takes `(...args: any[]) => void`.\n          newTarget.on(name, handler);\n        });\n      });\n    // remove old\n    oldTarget.removeAllListeners();\n  };\n\n  const proxy = new Proxy<Type>(target, {\n    // @ts-expect-error We are providing a different signature than the `get`\n    // option as defined in the Proxy interface; specifically, we've limited\n    // `name` so that it can't be arbitrary. Theoretically this is inaccurate,\n    // but because we've constrained what the `target` can be, that effectively\n    // constraints the allowed properties as well.\n    get(\n      _target: Type,\n      name: 'setTarget' | keyof Type,\n      receiver: SwappableProxy<Type>,\n    ): unknown {\n      // override `setTarget` access\n      if (name === 'setTarget') {\n        return setTarget;\n      }\n\n      const value = target[name];\n      if (value instanceof Function) {\n        return function (this: unknown, ...args: any[]) {\n          // This function may be either bound to something or nothing.\n          // eslint-disable-next-line no-invalid-this\n          return value.apply(this === receiver ? target : this, args);\n        };\n      }\n      return value;\n    },\n    // @ts-expect-error We are providing a different signature than the `set`\n    // option as defined in the Proxy interface; specifically, we've limited\n    // `name` so that it can't be arbitrary. Theoretically this is inaccurate,\n    // but because we've constrained what the `target` can be, that effectively\n    // constraints the allowed properties as well.\n    set(\n      _target: Type,\n      name: 'setTarget' | keyof Type,\n      // This setter takes either the `setTarget` function, the value of a a\n      // known property of Type, or something else. However, the type of this value\n      // depends on the property given, and getting TypeScript to figure this\n      // out is seriously difficult. It doesn't ultimately matter, however,\n      // as the setter is not visible to consumers.\n      value: any,\n    ): boolean {\n      // allow `setTarget` overrides\n      if (name === 'setTarget') {\n        setTarget = value;\n        return true;\n      }\n      target[name] = value;\n      return true;\n    },\n  });\n\n  // Typecast: The return type of the Proxy constructor is defined to be the\n  // same as the provided type parameter. This is naive, however, as it does not\n  // account for the proxy trapping and responding to arbitrary properties; in\n  // our case, we trap `setTarget`, so this means our final proxy object\n  // contains a property on top of the underlying object's properties.\n  return proxy as SwappableProxy<Type>;\n}\n"]}