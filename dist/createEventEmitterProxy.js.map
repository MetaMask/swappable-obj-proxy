{"version":3,"file":"createEventEmitterProxy.js","sourceRoot":"","sources":["../src/createEventEmitterProxy.ts"],"names":[],"mappings":";;;AAMA,MAAM,UAAU,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC;AAC9B,MAAM,cAAc,GAAwB,CAAC,aAAa,EAAE,gBAAgB,CAAC,CAAC;AAC9E,MAAM,mBAAmB,GAAG,CAAC,IAAqB,EAAE,EAAE,CACpD,CAAC,cAAc,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;AAEjC;;;;;;;;;;;;;GAaG;AACH,SAAgB,uBAAuB,CACrC,aAAgB,EAChB,EACE,WAAW,EAAE,gBAAgB,GAAG,UAAU,MAGxC,EAAE;IAEN,gBAAgB;IAChB,MAAM,WAAW,GACf,gBAAgB,KAAK,cAAc;QACjC,CAAC,CAAC,mBAAmB;QACrB,CAAC,CAAC,gBAAgB,CAAC;IAEvB,IAAI,OAAO,WAAW,KAAK,UAAU,EAAE;QACrC,MAAM,IAAI,KAAK,CAAC,+CAA+C,CAAC,CAAC;KAClE;IAED,IAAI,MAAM,GAAG,aAAa,CAAC;IAE3B;;;;OAIG;IACH,IAAI,SAAS,GAAG,CAAC,SAAc,EAAE,EAAE;QACjC,MAAM,SAAS,GAAG,MAAM,CAAC;QACzB,MAAM,GAAG,SAAS,CAAC;QACnB,oBAAoB;QACpB,SAAS;aACN,UAAU,EAAE;aACZ,MAAM,CAAC,WAAW,CAAC;aACnB,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;YAChB,SAAS;iBACN,YAAY,CAAC,IAAI,CAAC;iBAClB,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,SAAS,CAAC,EAAE,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC;QACvD,CAAC,CAAC,CAAC;QACL,aAAa;QACb,SAAS,CAAC,kBAAkB,EAAE,CAAC;IACjC,CAAC,CAAC;IAEF,MAAM,KAAK,GAAsB,IAAI,KAAK,CAAM,MAAM,EAAE;QACtD,GAAG,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,QAAW,EAAE,EAAE;YAC5B,8BAA8B;YAC9B,IAAI,IAAI,KAAK,WAAW,EAAE;gBACxB,OAAO,SAAS,CAAC;aAClB;YAED,uEAAuE;YACvE,kEAAkE;YAClE,6BAA6B;YAC7B,MAAM,KAAK,GAAI,MAAc,CAAC,IAAI,CAAC,CAAC;YACpC,IAAI,KAAK,YAAY,QAAQ,EAAE;gBAC7B,OAAO,UAA+B,GAAG,IAAW;oBAClD,iEAAiE;oBACjE,oBAAoB;oBACpB,2CAA2C;oBAC3C,OAAO,KAAK,CAAC,KAAK,CAAC,IAAI,KAAK,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBAC9D,CAAC,CAAC;aACH;YACD,OAAO,KAAK,CAAC;QACf,CAAC;QACD,GAAG,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE;YACtB,8BAA8B;YAC9B,IAAI,IAAI,KAAK,WAAW,EAAE;gBACxB,SAAS,GAAG,KAAK,CAAC;gBAClB,OAAO,IAAI,CAAC;aACb;YACD,uEAAuE;YACvE,kEAAkE;YAClE,6BAA6B;YAC5B,MAAc,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;YAC9B,OAAO,IAAI,CAAC;QACd,CAAC;KACF,CAAC,CAAC;IAEH,OAAO,KAAK,CAAC;AACf,CAAC;AA7ED,0DA6EC","sourcesContent":["// This package relies on the EventEmitter type.\n// eslint-disable-next-line import/no-nodejs-modules\nimport type { EventEmitter } from 'events';\n\nimport type { SwappableProxy } from './types';\n\nconst filterNoop = () => true;\nconst internalEvents: (string | symbol)[] = ['newListener', 'removeListener'];\nconst externalEventFilter = (name: string | symbol) =>\n  !internalEvents.includes(name);\n\n/**\n * Creates a proxy object that initially points to the given object but whose\n * target can be substituted with another object later using its `setTarget`\n * method. In addition, when the target is changed, event listeners which have\n * been attached to the target will be detached and migrated to the new target.\n *\n * @param initialTarget - The initial object you want to wrap.\n * @param opts - The options.\n * @param opts.eventFilter - Usually, listeners for all events will be migrated\n * from old targets to new targets, but this function can be used to select\n * which events you want to migrate. If you pass `'skipInternal'`, then\n * `newListener` and `removeListener` will be excluded.\n * @returns The proxy object.\n */\nexport function createEventEmitterProxy<T extends EventEmitter>(\n  initialTarget: T,\n  {\n    eventFilter: givenEventFilter = filterNoop,\n  }: {\n    eventFilter?: ((eventName: string | symbol) => boolean) | 'skipInternal';\n  } = {},\n): SwappableProxy<T> {\n  // parse options\n  const eventFilter =\n    givenEventFilter === 'skipInternal'\n      ? externalEventFilter\n      : givenEventFilter;\n\n  if (typeof eventFilter !== 'function') {\n    throw new Error('createEventEmitterProxy - Invalid eventFilter');\n  }\n\n  let target = initialTarget;\n\n  /**\n   * Changes the object that the proxy wraps.\n   *\n   * @param newTarget - The new object.\n   */\n  let setTarget = (newTarget: any) => {\n    const oldTarget = target;\n    target = newTarget;\n    // migrate listeners\n    oldTarget\n      .eventNames()\n      .filter(eventFilter)\n      .forEach((name) => {\n        oldTarget\n          .rawListeners(name)\n          .forEach((handler) => newTarget.on(name, handler));\n      });\n    // remove old\n    oldTarget.removeAllListeners();\n  };\n\n  const proxy: SwappableProxy<T> = new Proxy<any>(target, {\n    get: (_, name, receiver: T) => {\n      // override `setTarget` access\n      if (name === 'setTarget') {\n        return setTarget;\n      }\n\n      // Typecast: We cannot typecast `name` in the arguments for this option\n      // because it conflicts with the function signature, so we need to\n      // typecast `target` instead.\n      const value = (target as any)[name];\n      if (value instanceof Function) {\n        return function (this: T | undefined, ...args: any[]) {\n          // This function may be a method bound to the proxy object, or an\n          // unbound function.\n          // eslint-disable-next-line no-invalid-this\n          return value.apply(this === receiver ? target : this, args);\n        };\n      }\n      return value;\n    },\n    set: (_, name, value) => {\n      // allow `setTarget` overrides\n      if (name === 'setTarget') {\n        setTarget = value;\n        return true;\n      }\n      // Typecast: We cannot typecast `name` in the arguments for this option\n      // because it conflicts with the function signature, so we need to\n      // typecast `target` instead.\n      (target as any)[name] = value;\n      return true;\n    },\n  });\n\n  return proxy;\n}\n"]}