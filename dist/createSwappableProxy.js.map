{"version":3,"file":"createSwappableProxy.js","sourceRoot":"","sources":["../src/createSwappableProxy.ts"],"names":[],"mappings":";;;AAEA;;;;;;;;GAQG;AACH,SAAgB,oBAAoB,CAClC,aAAmB;IAEnB,IAAI,MAAM,GAAG,aAAa,CAAC;IAE3B;;;;OAIG;IACH,IAAI,SAAS,GAAG,CAAC,SAAe,EAAE,EAAE;QAClC,MAAM,GAAG,SAAS,CAAC;IACrB,CAAC,CAAC;IAEF,MAAM,KAAK,GAAG,IAAI,KAAK,CAAO,MAAM,EAAE;QACpC,yEAAyE;QACzE,wEAAwE;QACxE,0EAA0E;QAC1E,2EAA2E;QAC3E,8CAA8C;QAC9C,GAAG,CACD,OAAa,EACb,IAA8B,EAC9B,QAA8B;YAE9B,8BAA8B;YAC9B,IAAI,IAAI,KAAK,WAAW,EAAE;gBACxB,OAAO,SAAS,CAAC;aAClB;YAED,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;YAC3B,IAAI,KAAK,YAAY,QAAQ,EAAE;gBAC7B,OAAO,UAAyB,GAAG,IAAW;oBAC5C,6DAA6D;oBAC7D,2CAA2C;oBAC3C,OAAO,KAAK,CAAC,KAAK,CAAC,IAAI,KAAK,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBAC9D,CAAC,CAAC;aACH;YACD,OAAO,KAAK,CAAC;QACf,CAAC;QACD,yEAAyE;QACzE,wEAAwE;QACxE,0EAA0E;QAC1E,2EAA2E;QAC3E,8CAA8C;QAC9C,GAAG,CACD,OAAa,EACb,IAA8B;QAC9B,sEAAsE;QACtE,6EAA6E;QAC7E,uEAAuE;QACvE,qEAAqE;QACrE,6CAA6C;QAC7C,KAAU;YAEV,8BAA8B;YAC9B,IAAI,IAAI,KAAK,WAAW,EAAE;gBACxB,SAAS,GAAG,KAAK,CAAC;gBAClB,OAAO,IAAI,CAAC;aACb;YACD,MAAM,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;YACrB,OAAO,IAAI,CAAC;QACd,CAAC;KACF,CAAC,CAAC;IAEH,0EAA0E;IAC1E,8EAA8E;IAC9E,4EAA4E;IAC5E,sEAAsE;IACtE,oEAAoE;IACpE,OAAO,KAA6B,CAAC;AACvC,CAAC;AAvED,oDAuEC","sourcesContent":["import type { SwappableProxy } from './types';\n\n/**\n * Creates a proxy object that initially points to the given object but whose\n * target can be substituted with another object later using its `setTarget`\n * method.\n *\n * @template Type - An object.\n * @param initialTarget - The initial object you want to wrap.\n * @returns The proxy object.\n */\nexport function createSwappableProxy<Type extends object>(\n  initialTarget: Type,\n): SwappableProxy<Type> {\n  let target = initialTarget;\n\n  /**\n   * Changes the object that the proxy wraps.\n   *\n   * @param newTarget - The new object.\n   */\n  let setTarget = (newTarget: Type) => {\n    target = newTarget;\n  };\n\n  const proxy = new Proxy<Type>(target, {\n    // @ts-expect-error We are providing a different signature than the `get`\n    // option as defined in the Proxy interface; specifically, we've limited\n    // `name` so that it can't be arbitrary. Theoretically this is inaccurate,\n    // but because we've constrained what the `target` can be, that effectively\n    // constraints the allowed properties as well.\n    get(\n      _target: Type,\n      name: 'setTarget' | keyof Type,\n      receiver: SwappableProxy<Type>,\n    ): unknown {\n      // override `setTarget` access\n      if (name === 'setTarget') {\n        return setTarget;\n      }\n\n      const value = target[name];\n      if (value instanceof Function) {\n        return function (this: unknown, ...args: any[]) {\n          // This function may be either bound to something or nothing.\n          // eslint-disable-next-line no-invalid-this\n          return value.apply(this === receiver ? target : this, args);\n        };\n      }\n      return value;\n    },\n    // @ts-expect-error We are providing a different signature than the `set`\n    // option as defined in the Proxy interface; specifically, we've limited\n    // `name` so that it can't be arbitrary. Theoretically this is inaccurate,\n    // but because we've constrained what the `target` can be, that effectively\n    // constraints the allowed properties as well.\n    set(\n      _target: Type,\n      name: 'setTarget' | keyof Type,\n      // This setter takes either the `setTarget` function, the value of a a\n      // known property of Type, or something else. However, the type of this value\n      // depends on the property given, and getting TypeScript to figure this\n      // out is seriously difficult. It doesn't ultimately matter, however,\n      // as the setter is not visible to consumers.\n      value: any,\n    ): boolean {\n      // allow `setTarget` overrides\n      if (name === 'setTarget') {\n        setTarget = value;\n        return true;\n      }\n      target[name] = value;\n      return true;\n    },\n  });\n\n  // Typecast: The return type of the Proxy constructor is defined to be the\n  // same as the provided type parameter. This is naive, however, as it does not\n  // account for the proxy trapping and responding to arbitrary properties; in\n  // our case, we trap `setTarget`, so this means our final proxy object\n  // contains a property on top of the underlying object's properties.\n  return proxy as SwappableProxy<Type>;\n}\n"]}