{"version":3,"file":"createSwappableProxy.js","sourceRoot":"","sources":["../src/createSwappableProxy.ts"],"names":[],"mappings":";;;AAEA;;;;;;;GAOG;AACH,SAAgB,oBAAoB,CAAI,aAAgB;IACtD,IAAI,MAAM,GAAG,aAAa,CAAC;IAE3B;;;;OAIG;IACH,IAAI,SAAS,GAAG,CAAC,SAAY,EAAE,EAAE;QAC/B,MAAM,GAAG,SAAS,CAAC;IACrB,CAAC,CAAC;IAEF,MAAM,KAAK,GAAsB,IAAI,KAAK,CAAM,MAAM,EAAE;QACtD,GAAG,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAE,EAAE;YACzB,8BAA8B;YAC9B,IAAI,IAAI,KAAK,WAAW,EAAE;gBACxB,OAAO,SAAS,CAAC;aAClB;YAED,uEAAuE;YACvE,kEAAkE;YAClE,6BAA6B;YAC7B,MAAM,KAAK,GAAI,MAAc,CAAC,IAAI,CAAC,CAAC;YACpC,IAAI,KAAK,YAAY,QAAQ,EAAE;gBAC7B,OAAO,UAA+B,GAAG,IAAW;oBAClD,iEAAiE;oBACjE,oBAAoB;oBACpB,2CAA2C;oBAC3C,OAAO,KAAK,CAAC,KAAK,CAAC,IAAI,KAAK,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBAC9D,CAAC,CAAC;aACH;YACD,OAAO,KAAK,CAAC;QACf,CAAC;QACD,GAAG,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE;YACtB,8BAA8B;YAC9B,IAAI,IAAI,KAAK,WAAW,EAAE;gBACxB,SAAS,GAAG,KAAK,CAAC;gBAClB,OAAO,IAAI,CAAC;aACb;YACD,uEAAuE;YACvE,kEAAkE;YAClE,6BAA6B;YAC5B,MAAc,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;YAC9B,OAAO,IAAI,CAAC;QACd,CAAC;KACF,CAAC,CAAC;IAEH,OAAO,KAAK,CAAC;AACf,CAAC;AAhDD,oDAgDC","sourcesContent":["import type { SwappableProxy } from './types';\n\n/**\n * Creates a proxy object that initially points to the given object but whose\n * target can be substituted with another object later using its `setTarget`\n * method.\n *\n * @param initialTarget - The initial object you want to wrap.\n * @returns The proxy object.\n */\nexport function createSwappableProxy<T>(initialTarget: T): SwappableProxy<T> {\n  let target = initialTarget;\n\n  /**\n   * Changes the object that the proxy wraps.\n   *\n   * @param newTarget - The new object.\n   */\n  let setTarget = (newTarget: T) => {\n    target = newTarget;\n  };\n\n  const proxy: SwappableProxy<T> = new Proxy<any>(target, {\n    get: (_, name, receiver) => {\n      // override `setTarget` access\n      if (name === 'setTarget') {\n        return setTarget;\n      }\n\n      // Typecast: We cannot typecast `name` in the arguments for this option\n      // because it conflicts with the function signature, so we need to\n      // typecast `target` instead.\n      const value = (target as any)[name];\n      if (value instanceof Function) {\n        return function (this: T | undefined, ...args: any[]) {\n          // This function may be a method bound to the proxy object, or an\n          // unbound function.\n          // eslint-disable-next-line no-invalid-this\n          return value.apply(this === receiver ? target : this, args);\n        };\n      }\n      return value;\n    },\n    set: (_, name, value) => {\n      // allow `setTarget` overrides\n      if (name === 'setTarget') {\n        setTarget = value;\n        return true;\n      }\n      // Typecast: We cannot typecast `name` in the arguments for this option\n      // because it conflicts with the function signature, so we need to\n      // typecast `target` instead.\n      (target as any)[name] = value;\n      return true;\n    },\n  });\n\n  return proxy;\n}\n"]}